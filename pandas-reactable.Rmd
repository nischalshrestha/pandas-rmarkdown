---
title: "Python DataFrames in RMarkdown using `reticulate`, `kableExtra` and `formattable`"
author: "Nischal Shrestha"
date: "11/14/2020"
output:
  html_document:
    theme: cosmo
---

```{r setup, include = FALSE}
library(magrittr)
library(tidyverse)
library(reticulate)
library(emo)
library(nycflights13)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# custom script with helper functions
source(here::here("kable_experiment.R"))
home_path <- here::here("data/")
nba_data_path <- paste0(home_path, "nba.csv")
weather_data_path <- paste0(home_path, "weather.csv")
rnba <- read.csv(nba_data_path)
```

```{python echo = FALSE}
import pandas as pd
import numpy as np

arrays = [np.array(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux']),
        np.array(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'])]
tuples = list(zip(*arrays))
index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])
df_basic = pd.DataFrame(np.random.randn(8, 4), columns=['a','b','c','d'])
df_multi = pd.DataFrame(np.random.randn(8, 4), index = index, columns=['a','b','c','d'])
```

# But, why? `r emo::ji("thinking")`

Ok, fair question. Well, one day I was building a lesson in Python and I just had it with how ugly the default pandas DataFrame output looked on rmarkdown. Here's an example of a dataframe using `pandas`:

```{python echo=FALSE, fig.align="center"}
df_multi
```

Looking at this, I thought to myself we have all these amazing R packages for RMarkdown to render pretty dataframes so why not use them? I know what you're thinking: "But, you can't do that since all these great R packages only accept R dataframes!" 

Yes, fair point. But, what if I made an R dataframe "look" like a Python dataframe so I can still use these packages?

<p align="center">
  <img src="images/challengeaccepted.gif" width="480" height="349">
</p>

In this post, I talk about how I was able to use `{reticulate}` to mimic a Python `DataFrame`, and `{kableExtra}` together with `{formattable}` R packages to give some love to Python DataFrames rendering in RMarkdown documents. In the end, we will end up with something like this:

<!-- TODO: update final look here to be on grouped dataframes -->

<!-- ```{r echo=FALSE} -->
<!-- kable_pandas( -->
<!--   pydf = reticulate::py_eval("df_basic") -->
<!-- ) -->
<!-- ``` -->
<!-- and this for grouped dataframes: -->

```{r echo=FALSE}
kable_pandas(
  pydf = reticulate::py_eval("df_multi")
)
```

Keep in mind, the solutions I present in this post are largely dirty hacks, but it is truly amazing how far you can go with these packages, so let's begin!

# What does a `pandas.DataFrame` look like?

For a "good enough" visual representation of a Python `DataFrame` in `pandas`, I thought about some differences that need to be handled:

- 0-indexing
- Data types/structures with different output formats
- Python's crazy thing called `Index`

Of course, there are probably plenty of other differences beyond these, but I decided to handle these for now. I will use the raw `weather.csv` dataset from the `nycflights13` [package](https://github.com/hadley/nycflights13) to demonstrate how Python dataframes look different and how we can make them look pretty when printing in RMarkdown.

First, here's the R dataframe:

```{r}
nycflights13::weather
```

Now, I'm going to do the good ol', library imports for `pandas` + `numpy` and set up our dataframe in Python with US/Eastern timezone:

```{python}
import pandas as pd
import numpy as np
df = pd.read_csv(r.weather_data_path, parse_dates=['time_hour'])
df.time_hour = pd.to_datetime(df.time_hour.dt.tz_convert('US/Eastern'))
df
```

Ok, we can definitely see the 0-indexing difference in Python's output. We also see that R's dataframe output is a lot more informative on the column types. How about some more details on the columns?

R:

```{r}
glimpse(nycflights13::weather)
```

Python:

```{python}
df.info()
```

From above, we can see that the core data types are pretty much the same. `reticulate` will help us with those. But, we'll quickly come across a big difference in visual output with grouped dataframes. So, before we get to our table making fun, we need to explain the more complicated bit that will yield very different visual outputs: Python's `Index` and `MultiIndex`.

## Enter `Index` and `MultiIndex`

In `pandas`, there is a data structure called an `Index`, which you can kind of think of as the `key` column for your table. To me, the `Index` is one of the most confusing data structures, yet it is a core part of the DataFrame and Series data structures (similar to R `data.frame` and `vector`, respectively), and it allows us powerful indexing semantics. More on `Index` [here](https://pandas.pydata.org/pandas-docs/stable/reference/indexing.html).

This is all pretty vague so let's run through an example with our `weather` dataset. What's the index of our dataframe `df`?

```{python}
df.index
```

It's a `RangeIndex`, which is very similar to how we normally index R dataframes using numbers.

But now, let's say we want to reshape our `weather` dataframe by time (`time_hour`) and then by airport:

```{python}
df.set_index(['time_hour', 'origin'])
```

Ok, that looks a bit different! The `time_hour` and `origin` look like they belong together and are all the way to the left, and the rest of the actual columns are "raised". But, it's only when we sort the data by `time_hour`, that we actually see that our dataframe has been essentially grouped by these two columns:

```{python}
df.set_index(['time_hour', 'origin']).sort_values(by='time_hour')
```

In other words, this is no longer a regular dataframe but one that seems to have multiple `Index` levels into our table. To explain, let's set the new dataframe to `df` and print the index:

```{python}
# set index and return resulting DataFrame
df = df.set_index(['time_hour', 'origin']).sort_values(by='time_hour')
# index is now a MultiIndex
df.index
```

As you can see, we now have a `MultiIndex` for `df` where the names of the 2 levels are `time_hour` and `origin`. 

**The problem:** We don't really have a direct equivalent to `Index` or `MultiIndex` in R. We subset R dataframe rows using numerical indices (e.g. `df[1:2]`) or by `character` via `row.names` (e.g. `mtcars['Volvo 142E', ]`). However, the `Index` and `MultiIndex` in Python is a lot more complex because it also allows "heirarchical indexing", meaning we can have many levels of subsetting rows (and columns).

For example, reshaping our dataframe `df` now allows us to perform complex queries using just labels. Here, we index into rows for January for JFK using `loc`:

```{python}
df.loc[('January, 2013', 'JFK'), ]
```

Neat! Note how there are two levels of `Index` here, which forms a `MultiIndex`. Why do we need this? Well, because we now have a heirarchy of `Index` levels, we can use a subset operation via `loc` on a dataframe `df` to subset rows which corresponds to `'January, 2013'` on the `time_hour` level, then the `'JFK'` on the `origin` level. This is quite powerful, and is the basis of `groupby` operations.

Now, let's see how we can use `reticulate`, `kableExtra`, and `formattable` to make an R `data.frame` look like this `pandas.DataFrame`.




<!-- This is if we wanted the python dataframe to look like R for the date -->
<!-- df = pd.read_csv(r.weather_data_path, parse_dates=['time_hour']) -->
<!-- df.set_index('time_hour', inplace=True) -->
<!-- df.index = pd.to_datetime(df.index.tz_convert('US/Eastern').strftime('%m-%d-%Y %H:%M:%S')) -->
<!-- df.index -->

<!-- ## Import libraries -->

<!-- Let's first talk about what a Python DataFrame looks like in the first place  -->

<!-- ```{python} -->
<!-- import pandas as pd -->
<!-- import numpy as np -->
<!-- ``` -->

<!-- ## Simple example -->

<!-- ```{python} -->
<!-- arrays = [np.array(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux']), -->
<!--          np.array(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'])] -->
<!-- arrays -->
<!-- ``` -->

<!-- Example of what a Series with MultiIndex looks like: -->

<!-- ```{python} -->
<!-- s = pd.Series(np.random.randn(8), index = arrays, name = 'a') -->
<!-- s.index -->
<!-- # you can get the list representation of it which could be useful to translate via `reticulate` -->
<!-- s.index.values.tolist() -->
<!-- ``` -->

<!-- Example of what a DataFrame with MultiIndex looks like: -->

<!-- ```{python} -->
<!-- df = pd.DataFrame(np.random.randn(8, 4), index = arrays, columns=['a','b','c','d']) -->
<!-- print(df.index) -->
<!-- df -->
<!-- ``` -->

<!-- We can also directly set MultiIndex -->

<!-- ```{python} -->
<!-- tuples = list(zip(*arrays)) -->
<!-- index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second']) -->
<!-- index -->
<!-- ``` -->

<!-- Notice though, that when we set the index to this MultiIndex that has names for the levels, we get a visually different output: -->

<!-- ```{python} -->
<!-- df = pd.DataFrame(np.random.randn(8, 4), index = index, columns=['a','b','c','d']) -->
<!-- print(df.index) -->
<!-- df -->
<!-- ``` -->

<!-- ```{python} -->
<!-- arrays = [np.array(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux']), -->
<!--          np.array(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'])] -->
<!-- tuples = list(zip(*arrays)) -->
<!-- index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second']) -->
<!-- df = pd.DataFrame(np.random.randn(8, 4), index = index, columns=['a','b','c','d']) -->
<!-- df -->
<!-- ``` -->


<!-- This is to give you a visual indication that we have multiple row indices and they're set at a lower height than the columns. -->


<!-- # Real world example -->


<!-- ```{python nba_setup} -->
<!-- import pandas as pd -->
<!-- nba = pd.read_csv(r.nba_data_path) -->
<!-- nba -->
<!-- ``` -->



<!-- ```{python} -->
<!-- testing = {'Date':'date'} -->
<!-- column_names = { -->
<!--   'Date': 'date',  -->
<!--   'Start (ET)': 'start', -->
<!--   'Unamed: 2': 'box',  -->
<!--   'Visitor/Neutral': 'away_team', -->
<!--   'PTS': 'away_points',  -->
<!--   'Home/Neutral': 'home_team', -->
<!--   'PTS.1': 'home_points',  -->
<!--   'Unamed: 7': 'n_ot' -->
<!-- } -->
<!-- ``` -->

<!-- ```{python} -->
<!-- ( -->
<!--   nba.rename(columns=column_names) -->
<!--     .dropna(thresh=4) -->
<!--     [['date', 'away_team', 'away_points', 'home_team', 'home_points']] -->
<!--     .assign(date=lambda x: pd.to_datetime(x['date'], format='%a, %b %d, %Y')) -->
<!--     # .set_index('date', append=True) -->
<!--     # .rename_axis(['game_id', 'date']) -->
<!--     # .sort_index() -->
<!-- ) -->
<!-- ``` -->

<!-- # References -->


